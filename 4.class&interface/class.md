## OOP(Object-oriented Programming)
class: object를 정의한 설계도. object를 훨씬 쉽게 만들 수 있게 해준다.
object: 구체적인 실체, instance of classes.
        
## public & private 메소드/프로퍼티 [타입스크립트 문법]
클래스의 메소드 혹은 프로퍼티 앞에 private 키워드를 붙이면 private으로 바뀐다.
private 메소드와 프로퍼티는 클래스 내부에서만 접근 가능하다.
외부에서 해당 메소드 및 프로퍼티를 조작할 수 없도록 막고, 정해진 방식으로만 해당 메소드 및 프로퍼티에 접근할 수 있도록 통일시킬 때 사용하는 키워드이다. 
디폴트 값은 public으로, 일반적으로 정의된 메소드와 프로퍼티는 public 키워드가 생략되어 있는 것이라고 보면 된다.
이는 타입스크립트만의 문법이므로 브라우저 혹은 node와 같은 런타임은 이 키워드를 모른다. 
최신 자바스크립트에서는 # 키워드를 통해 private 프로퍼티와 메소드를 구현할 수 있긴 하다.
          
## protected 메소드 / 프로퍼티
private 프로퍼티는 해당 클래스에서만 접근이 가능하며, 상속된 클래스에서도 접근할 수 없다.
만약 상속된 클래스에서도 접근 가능한 private 속성을 원한다면 **protected** 키워드를 이용하면 된다.
protected 키워드는 보통 상속된 클래스에서 부모의 메소드를 override할 때 사용한다.
protected 메소드 및 프로퍼티의 변수명 첫글자는 _(underscore)로 하는 것이 컨벤션이다. > JS에서는 이름이 _로 시작하는 변수는 클래스 외부에서 웬만하면 접근하지 말자는 의미로 통용된다(private도 _로 시작하는 변수명이 컨벤션이었던 듯하다.).
         
## readonly 프로퍼티
변수명 앞에 readonly 키워드를 붙이면 읽기 전용 프로퍼티가 된다.
클래스 안에서든 밖에서든 해당 프로퍼티를 변경하고자 하면 에러가 발생한다.
readonly 키워드를 통해 의도치 않게 실수로 해당 속성을 변경하는 일을 방지하고, 코드의 의도를 명확히 할 수 있다.
타입스크립트만의 문법이다.
         
## getter(획득자)
객체의 속성을 호출했을 때 실행되는 메소드이다.
일반적으로, 특정 값을 바로 반환하지 않고 반환하기 이전에 특정 로직(결합, 수정, 유효성 검사 등)을 거치기 위해 사용한다.
         
## setter(설정자)
객체의 속성에 특정값을 부여할 때 실행되는 메소드이다.
일반적으로 속성 특정 값을 바로 부여하지 않고, 그 전에 특정 로직을 거치기 위해 사용한다.
            
*getter와 setter 모두 주로 캡슐화를 위해 사용한다. 즉, 오브젝트 내부의 성질을 오브젝트 외부에서 직접 관여하지 못하게 막고, 오직 오브젝트가 제공하는 특정 방식을 통해서만 관여할 수 있게끔 하기 위해 사용한다. private 변수를 지정한 후, 그 변수에 접근하기 위해 getter와 setter를 이용하는 방식이 일반적이다.
          
## static(정적) 메소드 및 프로퍼티
static 키워드를 이용하면 인스턴스가 아닌 클래스를 통해서만 접근 가능한 메소드 혹은 프로퍼티를 정의할 수 있다. static 키워드는 인스턴스가 아닌 클래스 자체에 속한 메소드 및 프로퍼티가 필요할 때 사용한다. static  메소드 및 프로퍼티를 클래스 내부에서 접근하기 위해서는 this 키워드가 아닌 class를 이용해야 한다. 왜냐하면 클래스 내부에서 this는 인스턴스를 가리키기 때문이다. 정적 메소드 혹은 프로퍼티를 정의하는 방식은 클래스의 프로퍼티 형태로 직접 정의하는 것과 똑같다. 
         
## abstract(추상) 클래스/ 메소드 
abstract 키워드는 해당 클래스를 상속받으면 특정 이름의 메소드를 반드시 갖고 있게 하되, 그 구체적인 내용을 정의하지는 않고자 할 때 사용한다. 하위 클래스가 해당 클래스의 일부 기능을 구현하도록 강제하는 것이다. abstract 메소드에는 세부 내용을 정의할 수 없다. 또한 abstract 클래스는 직접 생성자 함수로 활용될 수 없다. abstract 메소드를 선언하기 위해서는 반드시 class 선언부 앞에도 abstract 키워드를 붙여야 한다.       
        
## private constructor(개인 생성자) / 싱글턴(singleton) 패턴
**private constructor:** constructor 앞에 private 키워드를 붙이면 개인 생성자가 된다. 개인 생성자는 다른 private 메소드와 마찬가지로 클래스 내부에서만 호출 가능하다. 해당 클래스의 인스턴스를 단 하나만 생성해야 하는 경우 사용한다. getInstance와 같은 이름의 static 메소드를 정의하여 해당 메소드 내에서 개인 생성자를 호출함으로써 인스턴스를 만들어 반환한다. 다만 여기서 이미 인스턴스가 존재하는지 if문으로 확인한 후, 존재할 경우에는 기존의 인스턴스를 반환함으로써 하나의 인스턴스만 존재하도록 한다. 메모리 낭비를 방지할 수 있고 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽게 해주기 때문에 사용한다.      
**singleton pattern:** 싱글턴 패턴은 생성 패턴의 일종으로, 인스턴스를 하나만 생성하도록 하고, 이후에는 모든 클라이언트에게 동일한 인스턴스를 반환하는 패턴이다.        
~~~ts
class SomeClass {
  private static instance: SomeClass;

  private constructor(id: string, someProp: number) {}

  static getInstance() {
    if (SomeClass.instance) {
      return this.instance;
    }
    this.instance = new SomeClass('id', 1);
    return this.instance;
  }
}

const someInstance1 = new SomeClass('id', 2); // 개인 생성자를 외부에서 직접 호출했으므로 에러가 뜬다
const someInstance2 = SomeClass.getInstance(); // 정상적으로 인스턴스가 생성 및 반환된다.
~~~